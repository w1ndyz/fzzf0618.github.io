---
layout: post
title:  “TCP状态机拾遗”
date:   2020-05-20 22:24:59
author: Chris Wang
categories: ror
tags: tcp 三次握手 四次挥手
---

###### TCP的11个状态机

* 三次握手

1. `LISTEN`: 等待从对端TCP节点发送来的请求
2. `SYN_SENT`:表示TCP已经发送了一个`SYN`报文，代表应用程序执行了一个主动打开的操作，并等待对端回应此连接，并完成连接的建立
3. `SYN_RECV`:表示在`LISTEN`状态的TCP节点收到的对端的`SYN`报文，并已经通过发送`SYN/ACK`报文做出了响应。并等待对端TCP节点发送一个`ACK`，以此完成连接的建立，进入`ESTABLISHED`
4. `ESTABLISHED`:与对端TCP节点的连接建立完成。数据和报文可以在两个TCP节点之间双向交换

* 四次挥手

1. `FIN_WAIT1`:应用程序关闭了连接。TCP节点发送一个`FIN`报文到对端，以此终止本段的TCP连接，并等待对端发送`ACK`。这个状态以及接下来的三个状态都与应用程序执行的主动关闭有关
2. `FIN_WAIT2`:表示半连接状态，即有一方想要close连接，但是还要告诉另外对方，还有没有传完的数据需要传给你(`ACK`)，稍后再关闭连接。之前处在`FIN_WAIT1`状态的TCP节点收到了来自对端的`ACK`。
3. `TIME_WAIT`:表示收到了对方的`FIN报文`，并且发送了`ACK`报文。如果在`FIN_WAIT1`状态下收到了`FIN`和`ACK`的报文时，可以直接进入`TIME_WAIT`状态，无需进入`FIN_WAIT2`状态
4. `CLOSING`:比较少见的一个状态。一般情况下，当发送`FIN`报文时，应该先收到对端的`ACK`报文，再收到对端的`FIN`报文。但是`CLOSING`状态表示你发出`FIN`报文后，没有收到对方的`ACK`，却收到了对端的`FIN`。可以想象，如果两端同时close一个socket的话，就发生了同时发送`FIN`报文的情况，于是就出现了`CLOSING`状态，表示双方都在关闭socket
5. `CLOSE_WAIT`:表示正在等待关闭。当发起方准备关闭socket时，给接收方发送`FIN`，接收方会回应一个`ACK`给发起方，此时就进入了`CLOSE_WAIT`状态。如果接收方没有数据发给发起方了，就可以直接close这个socket。并发送`FIN`报文给发起方，即关闭连接。`CLOSE_WAIT`是等待接收方去关闭连接
6. `LAST_ACK`:表示接收方等待发起方发送最后的`ACK`报文，当接收到`ACK`报文时，即进入`CLOSED`状态
7. `CLOSED`:表示连接中断

###### 为何需要三次握手?

ans: 防止过期或失效连接又传给了服务端，因而产生错误。如果不使用三次握手，那么只要接收方发出了`SYN/ACK`，新的连接就建立了，由于过期或失效的连接没有发出建立连接的请求，于是不会响应接收方，不会发出`ACK`，但是接收方会认为新的连接已经建立，并一直等待发起方传输数据，这样接收方的很多资源就拜拜浪费掉了。主要是防止接收方一直等待，浪费资源

###### 为何需要四次挥手?

首先TCP是全双工的协议，那什么是全双工呢？下面是维基百科的解释:

> 全双工（**full-duplex**）的系统允许二台设备间同时进行双向数据传输。一般的电话、手机就是全双工的系统，因为在讲话时同时也可以听到对方的声音。全双工的系统可以用一般的双向车道形容。两个方向的车辆因使用不同的车道，因此不会互相影响。

接收到FIN时意味将没有数据再发来，但是还是可以继续发送数据

![](/assets/tcp.png)